## 思路：
- 利用动态规划
- 首先过一遍*不与str匹配的
- 分两种情况：
  - 前一个是*： 再分两种：是否匹配的上
  - 前一个不是*

```
 public boolean match(char[] str, char[] pattern)
    {
        
        boolean[][] dp = new boolean[pattern.length+1][str.length+1];
        dp[0][0] = true;
        for(int i=1;i<=pattern.length;i++){
            if(pattern[i-1]=='*')
                dp[i][0] = dp[i-2][0];//如果pattern中有*首先更新一遍不匹配str字符的情况
        }
        for(int i=1;i<=pattern.length;i++){
            for(int j=1;j<=str.length;j++){
                if(pattern[i-1]=='.' || pattern[i-1]==str[j-1])
                    dp[i][j] = dp[i-1][j-1];//如果1对一（包括完全匹配和.）
                else if(pattern[i-1]=='*'){
                    if(pattern[i-2]=='.' || pattern[i-2]==str[j-1]){
                        dp[i][j] |= dp[i-1][j];//当作一个字符且匹配
                        dp[i][j] |= dp[i-2][j];//当作0个字符
                        dp[i][j] |= dp[i][j-1];//不和当前str匹配，当作多个字符
                    }
                    else
                        dp[i][j] = dp[i-2][j];
                }                
            }
        }
        return dp[pattern.length][str.length];
    }
    
